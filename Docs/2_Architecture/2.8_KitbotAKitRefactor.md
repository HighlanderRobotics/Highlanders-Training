# Kitbot, now with AdvantageKit

## Intro
We'll be refactoring our kitbot code to apply what we just learned about AdvantageKit and how we structure our code with it.
"Refactoring" means rewriting code to improve its structure without changing its functionality.
We'll also learn how to use `StatusSignal`s to get loggable data from CTRE devices.


## Code Walkthrough

### Moving to AdvantageKit

The first step of moving our standard Command-based code to a loggable, simulateable structure is to install AdvantageKit.
Luckily, AdvantageKit has a handy guide on how to install it on an existing code base.
Follow [this walkthrough](https://docs.advantagekit.org/getting-started/installation/existing-projects).
Follow all the steps in the doc through changing it to `LoggedRobot`.

You do not need to add the suggested block in `Robot()`.
Instead, use the one below.
The suggested logging configuration is built around replaying logs, while we just want to simulate code.

```Java
Logger.getInstance().recordMetadata("ProjectName", "KitbotExample"); // Set a metadata value

    if (isReal()) {
      Logger.getInstance().addDataReceiver(new WPILOGWriter("/media/sda1/")); // Log to a USB stick
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
      new PowerDistribution(1, ModuleType.kRev); // Enables power distribution logging
    } else {
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
    }

    Logger.getInstance().start(); // Start logging! No more data receivers, replay sources, or metadata values may be added.
```

Once you've completed this, it's time to break `DrivetrainSubsystem` apart using the IO layer structure.

### Creating our IOInputs class

Recall the [IO layer structure](https://docs.advantagekit.org/getting-started/what-is-advantagekit/) for robot code.
Right now, we have one file for `DrivetrainSubsystem`.
Let's put it in a `Drivetrain` folder under `Subsystems` so that everything stays organized as we add more files.

![A screenshot showing the new folder](../../Assets/KitbotExampleSimScreenshot0.png)

Next, let's make a new file called `DrivetrainIO` in the same folder.
Remember that this file will define all the methods we use to interact with the hardware on the drivetrain.
You can use the `Create a new class/command` option when you right click on the folder to speed this up.
Make sure to change the type of `DrivetrainIO` to **interface**, not class.
(Feel free to google that or reference the HeadFirst Java book if you don't remember what that is.)

```Java
package frc.robot.Subsystems.Drivetrain;

public interface DrivetrainIO {}
```

Inside of this interface let's define our `IOInputs` class.
Remember this is a container for all of the inputs (sensor readings) and outputs (motor commands) for this mechanism.

```Java
public static class DrivetrainIOInputs {}
```

#### Voltage + velocity
Let's start by logging the output voltage of each side of the drivetrain.

```Java
public static class DrivetrainIOInputs {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;
}
```

Notice how we name our fields with units.
**It is very important to include units in all IOInputs variable names**.
It is very easy to assume different units in different places, which can cause frustrating and hard to find bugs.

Next, let's log the current velocity of each side of the drivetrain.

```Java
public static class DrivetrainIOInputs {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;

    public double leftVelocityMetersPerSecond = 0.0;
    public double rightVelocityMetersPerSecond = 0.0;
}
```

Notice the units.
This field is useful both for looking at drivetrain performance and also for tracking our position over time.
In fact, let's add a field for the current position of each side.

```Java
public static class DrivetrainIOInputs {
    // Snip
    public double leftPositionMeters = 0.0;
    public double rightPositionMeters = 0.0;
}
```

These values are useful for odometry.
Odometry is a way to track the robots position on the field by measuring how much each wheel is turning.
On a real robot we use it for auto so that we can draw paths on a map of the field instead of guessing where the robot should go.
For this sim we will use odometry to give us a position that we can use to visualize the robot on a fake field.

#### Current + temperature
On a real robot, it can be useful to log motor current draw and temperature.
Current draw is the amount of power the motor is actually using to try to reach its desired output, and is measured in Amperes (amps).
Checking current draw can be useful for things like verifying [current zeroing](2.2_ElectronicsCrashCourse.md#limit-switches) or to debug issues like a mechanism that draws too much current and causes other mechanisms to brown out.

The amount of power flowing through these motors also causes them to heat up over the course of a match.
When the motors get hotter, they get less efficient or may even shut down to prevent damage.
Logging the temperature of our motors can help us debug problems near the end of a match.
Normally, this issue is not too pronounced over the course of a single match.
However, in elims where we have a number of intense matches back to back or during drive practice where we run continuously for hours this can become an issue.
This simulation will not include temperature simulation, but it's good to get into the habit of including it in your logged values.

```Java
public static class DrivetrainIOInputs {
    // Snip
    public double leftCurrentAmps = 0.0;
    public double leftTempCelsius = 0.0;
    public double rightCurrentAmps = 0.0;
    public double rightTempCelsius = 0.0;
}
```

Seeing as we only have 1 motor on each side for this example, it makes more sense to leave these as doubles.
However, if you have multiple motors per side, you may want to make these arrays of doubles.

#### `@AutoLog` + `updateInputs`
Finally, to finish this IOInputs class we need to add the `@AutoLog` annotation above its definition.
This annotation automatically generates the code to log all this data in a new class called `IOInputsAutoLogged` so we don't have to worry about it.
However it is limited to only certain types of values, so be careful when making IOInputs classes.
If you want to log other types than `@AutoLog` supports, check out the [AdvantageKit docs](https://docs.advantagekit.org/data-flow/supported-types) on logging protobufs/structs.

Next, we need to add a method called `updateInputs` that takes in the `IOInputs` object and updates it based off of the new values from our sensors.
This needs to be called periodically to get the most up to date data.

```Java
public void updateInputs(DrivetrainIOInputs inputs);
```

#### Adding methods
Finally, let's add the methods that we use to interact with the hardware.
For this case it will just be a method `setVolts` to set the left and right output volts, like our `setVoltages` method that we have right now.

Now your `DrivetrainIO` file should look like this:

```Java
package frc.robot.Subsystems.Drivetrain;

import org.littletonrobotics.junction.AutoLog;

public interface DrivetrainIO {
    @AutoLog
    public static class DrivetrainIOInputs {
        public double leftOutputVolts = 0.0;
        public double rightOutputVolts = 0.0;

        public double leftVelocityMetersPerSecond = 0.0;
        public double rightVelocityMetersPerSecond = 0.0;

        public double leftPositionMeters = 0.0;
        public double rightPositionMeters = 0.0;

        public double leftCurrentAmps = 0.0;
        public double leftTempCelsius = 0.0;
        public double rightCurrentAmps = 0.0;
        public double rightTempCelsius = 0.0;
    }

    public void updateInputs(DrivetrainIOInputs inputs);

    public void setVolts(double left, double right);
}
```

### `DrivetrainIOReal`
Next, let's add the IO **implementation**.
This will be a file that defines *how* to "do the `updateInputs()` (how do we get and assign the data?) and `setVolts()` (how do we send a voltage to the motor?) methods.

#### Creating the class
Start by making a new class called `DrivetrainIOReal` in the Drivetrain folder.
Then, add `implements DrivetrainIO` to the class declaration.
This is very similar to using `extends`, except for interfaces instead of classes.
This means we could have multiple interfaces it implements, instead of just one class.

```Java
public class DrivetrainIOReal implements DrivetrainIO {}
```

This will make vscode angry since `DrivetrainIOReal` needs to implement all the template methods in `DrivetrainIO`.
Hover over it, hit "quick fix", and click "add unimplemented methods".
Now you should have a template for both of these methods.

```Java
public class DrivetrainIOReal implements DrivetrainIO {

    @Override
    public void updateInputs(DrivetrainIOInputs inputs) {
        // TODO Auto-generated method stub

    }

    @Override
    public void setVolts(double left, double right) {
        // TODO Auto-generated method stub

    }
}
```

#### Adding hardware
Before we get into implementing these, we need to add the hardware to this IO Implementation.
Add in the motors from `DrivetrainSubsystem`.

```Java
TalonFX leftTalon = new TalonFX(SwerveSubsystem.LEFT_TALON_ID);
TalonFX rightTalon = new TalonFX(SwerveSubsystem.RIGHT_TALON_ID);
```

Let's add all of the needed fields to `updateInputs`, even though we won't be able to set any of them yet.
One way to get all of the needed fields is to copy and paste the body of `DrivetrainIOInputs` into `updateInputs`.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;

    public double leftVelocityMetersPerSecond = 0.0;
    public double rightVelocityMetersPerSecond = 0.0;

    public double leftPositionMeters = 0.0;
    public double rightPositionMeters = 0.0;

    public double leftCurrentAmps = 0.0;
    public double leftTempCelsius = 0.0;
    public double rightCurrentAmps = 0.0;
    public double rightTempCelsius = 0.0;
}
```

Then replace the `public` and types with `inputs.`

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    inputs.leftOutputVolts = 0.0;
    inputs.rightOutputVolts = 0.0;

    inputs.leftVelocityMetersPerSecond = 0.0;
    inputs.rightVelocityMetersPerSecond = 0.0;

    inputs.leftPositionMeters = 0.0;
    inputs.rightPositionMeters = 0.0;

    inputs.leftCurrentAmps = 0.0;
    inputs.leftTempCelsius = 0.0;
    inputs.rightCurrentAmps = 0.0;
    inputs.rightTempCelsius = 0.0;
}
```

#### Status Signals
Now, how do we get these values?
The `StatusSignal` class is how we can get live data reported by a CTRE device, like position, velocity, etc.
Here, we'll be looking at the values we get from a TalonFX, but you can also get useful `StatusSignal`s from Pigeons, CANcoders, etc.
We'll update these every loop to get the latest data from each device.

Which `StatusSignal` we use depends on what data we want to collect.
Since we want to know the voltage draw of the left and right motors, we will need 2 `StatusSignal<Voltage>`s.
We'll define these member variables at the top of `DrivetrainIOReal`.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftTalon = new TalonFX(SwerveSubsystem.LEFT_TALON_ID);
    TalonFX rightTalon = new TalonFX(SwerveSubsystem.RIGHT_TALON_ID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage;
    private final StatusSignal<Voltage> rightAppliedVoltage;
}
```

Then, we'll instantiate these signals and match them to the correct motors + signal type.
Call `.getMotorVoltage();` on both of these motors, which returns a `StatusSignal<Voltage>,` and assign that to their respective signals.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftTalon = new TalonFX(SwerveSubsystem.LEFT_TALON_ID);
    TalonFX rightTalon = new TalonFX(SwerveSubsystem.RIGHT_TALON_ID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage = leftTalon.getMotorVoltage();
    private final StatusSignal<Voltage> rightAppliedVoltage = rightTalon.getMotorVoltage();
}
```

Go ahead and fill out the rest of the status signals in the same way.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftTalon = new TalonFX(SwerveSubsystem.LEFT_TALON_ID);
    TalonFX rightTalon = new TalonFX(SwerveSubsystem.RIGHT_TALON_ID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage = leftTalon.getMotorVoltage();
    private final StatusSignal<Voltage> rightAppliedVoltage = rightTalon.getMotorVoltage();
    private final StatusSignal<AngularVelocity> leftAngularVelocityRPS = leftTalon.getVelocity();
    private final StatusSignal<AngularVelocity> rightAngularVelocityRPS = rightTalon.getVelocity();

    // A little hacky - the units don't match, but that would typically be handled in the 
    // SensorToMechanismRatio config. For the purposes of this lesson, YOU DO NOT NEED TO
    // WORRY ABOUT THIS, but ask a lead if you have questions!
    private final StatusSignal<Angle> leftPositionMeters = leftTalon.getPosition(); 
    private final StatusSignal<Angle> rightPositionMeters = rightTalon.getPosition(); 

    private final StatusSignal<Current> leftSupplyCurrent = leftTalon.getSupplyCurrent();
    private final StatusSignal<Current> rightSupplyCurrent = rightTalon.getSupplyCurrent();
    private final StatusSignal<Temperature> leftTempCelsius = leftTalon.getDeviceTemp();
    private final StatusSignal<Temperature> rightTempCelsius = rightTalon.getDeviceTemp();
}
```
The values of these signals will need to be updated every loop (every 20 milliseconds, which equals 50 hertz).
This will need to be set in the `DrivetrainIOReal` constructor, so that it will get called when a new drivetrain object is created.

```Java
public DrivetrainIOReal() {
    // Sets the following status signals to be updated at a frequency of 50hz
    BaseStatusSignal.setUpdateFrequencyForAll(
        50.0, // update every 20ms
        leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);
}
```

At the top of `updateInputs()` (which gets called periodically), we're going to refresh all these signals with the `BaseStatusSignal.refreshAll()` method.
We'll pass in all our status signals as parameters.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    BaseStatusSignal.refreshAll(leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);
}
```

#### Getting the `StatusSignal` values
Now that we have the latest data for all these signals, we can log them.
Let's get those values and set the corresponding fields in `inputs` equal to them.
You'll need to call some sort of `.getValueAsDouble()` on these signals, since we can't use the `StatusSignal` directly.
You might also need to then create a new `Rotation2d` or something similar from that depending on what the field is.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    BaseStatusSignal.refreshAll(leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);

    inputs.leftOutputVolts = leftAppliedVoltage.getValueAsDouble();
    inputs.rightOutputVolts = rightAppliedVoltage.getValueAsDouble();

    inputs.leftVelocityMetersPerSecond = leftAngularVelocityRPS.getValueAsDouble();
    inputs.rightVelocityMetersPerSecond = rightAngularVelocityRPS.getValueAsDouble();

    inputs.leftPositionMeters = leftPositionMeters.getValueAsDouble();
    inputs.rightPositionMeters = rightPositionMeters.getValueAsDouble();

    inputs.leftCurrentAmps = leftSupplyCurrent.getValueAsDouble();
    inputs.leftTempCelsius = rightSupplyCurrent.getValueAsDouble();
    inputs.rightCurrentAmps = rightSupplyCurrent.getValueAsDouble();
    inputs.rightTempCelsius = rightTempCelsius.getValueAsDouble();

}
```
Your `DrivetrainIOReal` class is now complete!

### Refactoring `DrivetrainSubsystem`
Let's refactor our `DrivetrainSubsystem` to finish off this rewrite.

First, we need to replace all the functionality that moved to `DrivetrainIOReal` with an instance of `DrivetrainIOReal`.
Get rid of the `TalonFX` objects and `VoltageOut` requests, since those have all been moved to `DrivetrainIOReal.`

```Java
public class DrivetrainSubsystem extends SubsystemBase {
    DrivetrainIO io = new DrivetrainIOReal();
    // Snip
}
```

Then we should add an instance of the `DrivetrainIOInputs` class we just made to track all the inputs for the drivetrain.
Since we used the `@AutoLog` annotation, the class we actually want to use is `DrivetrainIOInputsAutoLogged`, which was automatically generated for us.

```Java
public class DrivetrainSubsystem extends SubsystemBase {
    DrivetrainIO io = new DrivetrainIOReal();
    DrivetrainIOInputsAutoLogged inputs = new DrivetrainIOInputsAutoLogged();
}
```

Add a call to `io.updateInputs(inputs)` in the `periodic()` method of `DrivetrainSubsystem`.

```Java
@Override
public void periodic() {
    io.updateInputs(inputs);
}
```

Then we need to push those inputs to the log, and also give them a name so we know that these inputs are coming from the drivetrain.
When you look at a log or sim in AdvantageScope, this is what organizes stuff into a folder in the sidebar.
We do this by calling `Logger.getInstance().processInputs("Drivetrain", inputs)`.

```Java
@Override
public void periodic() {
    io.updateInputs(inputs);
    Logger.getInstance().processInputs("Drivetrain", inputs);
}
```

Finally, let's change the `setVoltages` method to use the io layer.

```Java
private void setVoltages(double left, double right) {
    io.setVolts(left, right);
}
```
*This still calls the same `setControl` method on the same `TalonFX` objects that it did before*â€”the only difference is that it now goes through `DrivetrainIOReal` first.

And that's basically it!
In a future lesson, you'll learn how to simulate all of this as well.

This general structure of motors/other devices -> `ControlRequest`s and `StatusSignal`s -> various methods + `updateInputs()` is important and used across mechanisms, so use this to guide you as you write more mechanisms in the future.