# Intro to Controls

## Going from a goal for a mechanism ("Extend the elevator to 24 inches out" or "Have the drivetrain follow a path in autonomous") to the actual voltage sent to each motor is a non-trivial task

Therefore, 
> controls engineering is the study of how to design additional mechanisms to bridge the gap from what the user wants a mechanism to do, to how the mechanism is actually manipulated.

Start by reading through the [Advanced Controls Introduction in the WPILib docs](https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/control-system-basics.html) (you should read all the articles under Advanced Controls Introduction, not just Control System Basics).
You don't need to fully digest the math or jargon, but try to be familiar with the concepts behind PID and Feedforward, and understand the tradeoffs of each.
You should also tune the interactive models in the pages that have them.

If you're still confused after reading through those articles, that's okay! 
The articles are somewhat dense.
The rest of this article is basically notes on the WPILib articles + some intuition on how tuning works.
It's worth coming back to these explanations again later once you've digested it a little bit.
Kevin also has a spiel about PID controllers _which we should record and put here_.

Choosing a control strategy is an important takeaway from these articles.
Generally we have a pretty direct tradeoff between time/effort spent on controls and precision in our output (as well as how fast the mechanism gets to that precise output!)
Loosely speaking, there are 3 'levels' of control that we tend to use for our mechanisms.

### 1. Simple feedforward control.
   Feedforward is also known as open loop.
   It doesn't incorporate any knowledge of where the system currently is, and therefore can't adjust its behavior to correct for errors (hence there's a open gap in the "loop" of info going from output back to input, which if you think about it makes for a pretty terrible "loop" but regardless).
   You could think of this as basically just throwing a voltage at a motor.
   
   You'll usually see plain feedforward on **intakes or routing wheels**, where we just want to pull a game piece into or through the robot.
   These don't need to be super precise since they just need *some* rotation to work, so we're not really concerned with correcting error.
   The [Roller Subsystem](https://github.com/HighlanderRobotics/Reefscape/blob/83a11f1bb1dfd20c04c3dc6a0e548773f11dfc58/src/main/java/frc/robot/subsystems/roller/RollerSubsystem.java#L45) and [RollerIOReal class](https://github.com/HighlanderRobotics/Reefscape/blob/83a11f1bb1dfd20c04c3dc6a0e548773f11dfc58/src/main/java/frc/robot/subsystems/roller/RollerIOReal.java#L99) from 2025 is an example of this.

   Feedforward can also be combined with feedback, which will be covered below.

### 2. Simple feedback control.
   When people talk about "getting feedback" in daily life, they're asking to get comments based on their performance so they can change something and improve.
   Feedback control operates on the same idea.
   The system will put out some control effort, then find the difference between the setpoint and where it actually is, and then *adjust the control effort* to decrease that error.
   Feedback is also known as closed loop—which makes sense because we're taking knowledge of the error and feeding it back into the system, which *closes the loop*.
   
   Anything that uses feedback control will necessitate some knowledge of physical characteristics of your system—so stuff like moment of inertia or mass—in order to create an accurate model of the system.
   That model is necessary to effectively calculate how your system is *supposed* to respond to inputs, so you can figure out how to make up for the error.
   We get some of these values from CAD, some from [SysID](https://docs.wpilib.org/en/stable/docs/software/advanced-controls/system-identification/introduction.html), and some from hand tuning.
   More on this in the PID article

   Feedback control is needed when we're controlling 1) the **position** of a mechanism or 2) a mechanism that's **subject to a lot of changes** for whatever reason (like a flywheel launching game pieces, which exert **outside forces** on the flywheel that are hard to model).

   PID control is an example of feedback control. **If you see this: the PID video and video notes are coming soon. ask Athena or Kevin for now**

   Feedback-**only** control is usually used for mechanisms that are so overpowered compared to the forces on them that we can ignore outside forces.
   Often we use this by calling a TalonFX's Position or Velocity control modes.
   [The angle motor on a swerve module](https://github.com/HighlanderRobotics/Reefscape/blob/83a11f1bb1dfd20c04c3dc6a0e548773f11dfc58/src/main/java/frc/robot/subsystems/swerve/ModuleIOReal.java#L203) is an example of this sort of control, and works because the Kraken X60 powering the module angle is so much stronger than the friction of the wheel with the ground.

### 3. Combined feedforward and feedback control.
   This is ideal for situations where we desire precise control of a mechanism (which is most primary mechanisms of a robot).
   The signal from the feedforward goes towards **keeping** the mechanism where we want it (for example, it takes power to keep a vertical arm stationary when gravity is exerting a downward force on it), and the feedback signal goes to correcting error.

   Although this combined approach requires more effort to tune and model than the previous levels alone, it's the most precise way we use to control mechanisms.
   Generally, we now run a PID control loop onboard the motor's own controller (TalonFX) through `ControlRequest`s (covered in [Lesson 2.5](Docs\2_Architecture\2.5_KitbotExampleWalkthrough.md)).
   A good example is our code to [drive a swerve module](https://github.com/HighlanderRobotics/Reefscape/blob/83a11f1bb1dfd20c04c3dc6a0e548773f11dfc58/src/main/java/frc/robot/subsystems/swerve/ModuleIOReal.java#L198).
   We pass the `driveControlVelocity` request, which is a `VelocityTorqueCurrentFOC` `ControlRequest`, to the drive motor.
   `VelocityTorqueCurrentFOC` uses ["PID to [get to] a target velocity"](https://api.ctr-electronics.com/phoenix6/release/java/com/ctre/phoenix6/controls/VelocityTorqueCurrentFOC.html).
   We can also use the `.withFeedForward` method to also use feedforward control on the drive motor's velocity, which is the part on line 198.

   WPILib also provides several feedforward classes that model common mechanisms, like arms, elevators, and simple motors.
   Nowadays, we tend to use this for simulated mechanisms since we can just handle it onboard the motor in real life.
   The [elevator simulation from 2025](https://github.com/HighlanderRobotics/Reefscape/blob/83a11f1bb1dfd20c04c3dc6a0e548773f11dfc58/src/main/java/frc/robot/subsystems/elevator/ElevatorIOSim.java#L53) is an example of this, specifically the implementation of the `setTarget()` method.
   Here, instead of running the PID calculations onboard the motor (since we're in sim), we add the results of a PID controller calculation with a feedforward controller calculation.
   [This article](https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html#feedforward-control-in-wpilib) goes over the classes in more detail.
   Using these means we can avoid a lot of the math involved in feedforward control, but if you are interested in the math you can check out [this book](https://file.tavsys.net/control/controls-engineering-in-frc.pdf), although that is not required for the level of controls we are working with in FRC.

   WPILib's own PIDController can also be used to control things that we can't or don't want to run on a TalonFX.
   We use this a lot for things like autoalign, where instead of trying to get to a particular velocity or extension height, we're trying to to align the whole robot to a particular pose on the field.
   We treat the desired pose as the setpoint, calculate the error between the robot's current pose and the setpoint, and then pass the components of that to the command that drives the robot to get it closer to that pose.

### Examples

- Almost all of our mechanisms use feedforward/feedback control in some way, shape, or form. Take a look through `Subsystem` and `IOReal` files from our most recent robot!

### Exercises

- Complete all interactive WPILib tutorials and demonstrate tuning one of them to a lead or mentor
